/**
 *this service will perform common tasks for oracle-db via 'oracledb' [official node module from oracle]
 *@ayanb
 *@111215 
 */

//instantiate required module
var oracledb = require('oracledb');

/**
 * this function will not take any parameters.
 * static parameters should be changed from here directly if required
 */

//var o = {};

var o = {
  actionType:null,
  dbName:null,
  tableName:null,
  fromString: null,
  whereString: null,
  selectString: null,
  intoString: null,
  insertString: null,
  updateString:null,
  deleteString:null,
  limitString: null,
  orderByString: null,
  insertValue:[],
  updateValue:[],
  placeholderString:null,
  connect: function(cb) {

    console.log("connecting to database");
    oracledb.getConnection({
        user: "system",
        password: "password",
        connectString: "CONN_STRING"
      },
      function(err, con) {
        if (err) {
          console.error(err.message);
          cb(null);
        }
        cb(con);
      });

    return this;

  },
  releaseConnection: function(connection) {
    console.log("releasing database connection");
    connection.release(
      function(err) {
        if (err) {
          console.error(err.message);
        }
          
      });

   return this;

  },
  clearData:function(){

    this.actionType = null;
    this.dbName= null;
    this.tableName= null;
    this.fromString =  null;
    this.whereString =  null;
    this.selectString =  null;
    this.intoString =  null;
    this.insertString =  null;
    this.updateString =  null;
    this.deleteString =  null;
    this.limitString =  null;
    this.orderByString =  null;
    this.insertValue = [];
    this.updateValue = [];
    this.placeholderString = null;
  },

  from: function(dbName, tableName) {
    //if already value is set, clear it
    if (this.fromString) {
      this.fromString = null;
    }
    if (dbName && tableName) {
      this.dbName = dbName;
      this.tableName = tableName;
      this.fromString = "FROM " + dbName + "." + tableName + " ";
    }
   
    return this;


  },
  into: function(dbName, tableName) {
    //if already value is set, clear it
    if (this.intoString) {
      this.intoString = null;
    }
    if (dbName && tableName) {
      this.dbName = dbName;
      this.tableName = tableName;
      switch (this.actionType){
        case 'fetch':
          this.intoString = "INSERT INTO " + dbName + "." + tableName + " ";
        break;

        case 'update':
          this.intoString = "UPDATE "+ dbName + "." + tableName + " ";
        break;
      }
      
    }
    
    //console.log(this.intoString+this.insertString);
    //console.log(this.insertValue);
    //console.log(this.intoString+this.updateString);
    return this;


  },
  where: function(whereObject) {

    if (typeof whereObject !== 'object') {
      return;
    }
    var index = 0;
    var GAP = " "; //specifying single gap or space as variable
    var where_string = "WHERE";
    where_string += GAP; //adding space
    for (var i in whereObject) {
      //if this is not the first iteration then append "ADD"
      if (index !== 0) {
        where_string += "AND";
        where_string += GAP; //adding space
      }

      where_string += i; //adding key
      where_string += GAP; //adding space
      where_string += "="; //adding equal
      where_string += "\'" + whereObject[i] + "\'"; //adding val
      where_string += GAP; //adding space
      //we have to apend "AND" for an extra where clause, but only if current iteration is not the last one of 
      //the where object

      //increment the index variable
      index++;
    }

    console.log(where_string);
    this.whereString = where_string;
    return this;

  },
  limit: function(limit_to_num) {
    if (limit_to_num) {
      this.limitString = this.whereString ? "AND rownum <=" + limit_to_num : "WHERE rownum <=" + limit_to_num;
    }
    return this;
  },
  order: function(colName, orderWith) {
    if (!colName) {
      return;
    }
    if (!orderWith) {
      orderWith = 'ASC';
    }
    this.orderByString = " ORDER BY " + colName + " " + orderWith;
    return this;
  },
  fetch: function(columns) {
    this.actionType = 'fetch';
    var columnsFinal;
    if (typeof columns !== 'object' || columns === null) {
      columnsFinal = '*';
    } else {
      //blank string
      var column_string = "";
      for (var i in columns) {
        //concating with each column name from the coloumns array
        column_string += columns[i];
        column_string += ",";
        //now we need a comma, but not on the last iteration
      }
      //remove the last comma
      var columnsFinal = column_string.slice(0, -1);
    }


    var GAP = " ";
    this.selectString = "SELECT" + GAP + columnsFinal + GAP;
    return this;


  },
  insert:function(rowColumn){
    this.actionType = 'insert';
    //var insert_string = "";
    var field_string = ""; //(id,fname,lname)
    var placeholder_string = ""; //(:1,:2,:3)
    //var value_string = []; //[null,'ayan','banerjee']
    var index = 0;
    var GAP = " "; //space

    field_string += "(";
    placeholder_string += "(";

    for (var i in rowColumn) {
      if (index !== 0) {
        field_string += ",";
        placeholder_string += ",";
      }

      field_string += i; //concating field string
      this.insertValue.push(rowColumn[i]); //adding value  to array
      placeholder_string += ":" + (index + 1); //concating placeholder string

      //increment the index variable, this is for manually tracking 
      index++;
    }

    field_string += ")";
    placeholder_string += ")";

    this.insertString = field_string + GAP + "VALUES" + GAP + placeholder_string;

    
    return this;
  },
  update:function(updateData){
    this.actionType = 'update';
    this.updateString = "SET ";

    var index = 0;
    var placeholder_string = "";

    for (var i in updateData) {

      if (index !== 0) {
        this.updateString += ",";
      }

      this.updateString += i; //column name
      this.updateString += " = " //assignment operator
      this.updateString += ":" + (index + 1) //new placeholder of column
      this.updateValue.push(updateData[i]); //adding value  to array

      //increment the index variable, this is for manually tracking 
      index++;

    }
    
    return this;
     
  },
  delete:function(){
    this.actionType = 'delete';
    this.deleteString = "DELETE ";
    return this;
  },
  //this is the final function of the chain with callback support, now this 
  //function should be same for all chains like 'fetch', 'insert', 'update'
  exec: function(cb) {

    var query = "";
    var valueString = [];
    var options = {};

    //join parts of queries
    if (this.intoString) {
      query += this.intoString;
    }
    if (this.insertString) {
      query += this.insertString;
    }
    if (this.selectString) {
      query += this.selectString;
    }
    if (this.updateString) {
      query += this.updateString;
    }
     if (this.deleteString) {
      query += this.deleteString;
    }
    
    if (this.fromString) {
      query += this.fromString;
    }
    if (this.whereString) {
      query += this.whereString;
    }
    if (this.limitString) {
      query += this.limitString;
    }
    if (this.orderByString) {
      query += this.orderByString;
    }

    switch(this.actionType){
      case 'fetch':
        valueString = [];
        options = {outFormat: oracledb.OBJECT,maxRows: 50000};
        console.log(query);
        console.log(valueString);
        console.log(options);
        startFetch();
      break;

      case 'insert':
        valueString = this.insertValue ? this.insertValue : [];
        options  = { autoCommit: true };
        console.log(query);
        console.log(valueString);
        console.log(options);
        startInsert();
      break;

      case 'update':
        valueString = this.updateValue ? this.updateValue : [];
        options  = { autoCommit: true };
        console.log(query);
        console.log(valueString);
        console.log(options);
        startUpdate();
      break;

      case 'delete':
        valueString = [];
        options  = { autoCommit: true };
        startDelete();
      break;

    }

    function startFetch(){

      o.connect(function(con) {
        con.execute(
        query, valueString,options,
        function(err, result) {

          if (err) {console.error(err.message); cb(null); } 
            //no error here
            //send responce
            cb(result.rows);
            
            //reset variables
            o.clearData();
            //release oracle connection
            o.releaseConnection(con);
      });
    });

    }

    function startUpdate(){

      o.connect(function(con) {
        con.execute(
        query, valueString,options,
        function(err, result) {

          if (err) {console.error(err.message); cb(null); } 
            //no error here
            //send responce
            cb(result);
            
            //reset variables
            o.clearData();
            //release oracle connection
            o.releaseConnection(con);
      });
    });

    }

    function startDelete(){

       o.connect(function(con) {
        con.execute(
        query, valueString,options,
        function(err, result) {

          if (err) {console.error(err.message); cb(null); } 
            //no error here
            //send responce
            cb(result);
            
            //reset variables
            o.clearData();
            //release oracle connection
            o.releaseConnection(con);
      });
    });

    }

    function startInsert(){

      o.connect(function(con) {
        con.execute(
        query, valueString,options,// bind value for :id 
        function(err, result) {

          if (err) {console.error(err.message); cb(null); } 

            //now insert query is successfull, but we need to return the lastinsert id, we have to do it manually in oracle
            //this function will only execute if this is an insert query, not required for fetch query
            //we assume that the sequence name will be like this 'table_name_seq'

            //no error here
            con.execute("select "+o.dbName+"."+o.tableName+"_id_seq.currval from dual", [], {}, function(err, currval) {

              if (err) {console.error(err.message); cb(null); } 
              //no error here
              
              var last_insert_id = currval.rows[0][0] ;

              con.execute("select * from "+o.dbName+"."+o.tableName+" where country_id="+last_insert_id, [], {outFormat: oracledb.OBJECT,maxRows: 50000}, function(err, lastRow) {

               if (err) {console.error(err.message); cb(null); } 

                //send responce
                cb(lastRow.rows);
                
                //reset variables
                o.clearData();
                //release oracle connection
                o.releaseConnection(con);

              });

            });

          });
});

}

    
  }
  
}
module.exports = o;
